import '_Native_Socket' as s
import 'thread' as thread

import 'cookie.sf' as cookie

codes = {
    '200': 'OK',
    '201': 'Created',
    '204': 'No Content',
    '301': 'Moved Permanently',
    '302': 'Found',
    '400': 'Bad Request',
    '401': 'Unauthorized',
    '403': 'Forbidden',
    '404': 'Not Found',
    '500': 'Internal Server Error',
    '502': 'Bad Gateway',
    '503': 'Service Unavailable'
}

shut_codes = {
    'SHUT_RD': 0,
    'SHUT_WR': 1,
    'SHUT_RDWR': 2
}

class Server
    port = 0
    host = ''
    r_get = {}
    r_post = {}

    fun _init (self, host, port)
        self.port = port
        self.host = host
    
    fun add_get (self, route, callback)
        self.r_get[route] = callback
    
    fun add_post (self, route, callback)
        self.r_post[route] = callback
    
    fun gen_response (self, route, req, protocol)

        if protocol == 'GET'
            a = self.r_get[route] (req)
        else if protocol == 'POST'
            a = self.r_post[route] (req)
        
        p = a['status']
        as_str = p.to_string ()

        if not as_str in codes
            return ''

        r = "HTTP/1.1 " + as_str + ' ' + codes[as_str] + '\r\n'
        for j in a
            if not j in ['status', 'body', 'cookie']
                r = r + j + ': ' + a[j] + '\r\n'
        
        if 'cookie' in a
            for j in a['cookie']
                r = r + j.to_string () + '\r\n'
        
        if 'body' in a
            r = r + 'Content-Length: ' + len (a['body']).to_string () + '\r\n'
            r = r + '\r\n' + a['body']
                
        return r
    
    fun process (self, cs)
        req = s.read (cs)
        protocol = req[0 to req.find (' ')]

        lreq = len (req)
        lp1 = len (protocol) + 1
        rf = req[lp1 to lreq]
        rf = rf.find (' ')
        rf = rf + lp1
        path = req[lp1 to rf]

        body_idx = req.find ('\r\n\r\n')

        if body_idx != -1
            body = req[body_idx + 4 to len (req)]
            req = req[0 to body_idx]
        else
            body = ''

        rsp = [""]
        for i in 0 to len (req)
            if req[i] == '\n'
                rsp.push ('')
            else
                rsp[-1] = rsp[-1] + req[i]
        
        req_dict = {}
        for i in rsp
            if ':' in i
                # key = ''
                # val = ''
                # saw_colon = false

                # for jk in 0 to len (i)
                #     j = i[jk]
                #     if j == ':' and not saw_colon
                #         saw_colon = true
                #         continue
                    
                #     if saw_colon
                #         val = val + j
                #     else
                #         key = key + j
                
                # sfr = 0
                # while key[sfr] == ' '
                #     sfr = sfr + 1

                # key = key[sfr to len (key)]

                # sfr = 0
                # while val[sfr] == ' '
                #     sfr = sfr + 1

                # val = val[sfr to len (val)]
                # req_dict[key] = val

                colon_idx = 0

                for jk in 0 to len (i)
                    j = i[jk]

                    if j == ':'
                        colon_idx = jk
                        break
                
                key = i[0 to colon_idx]
                li = len (i)
                val = i[colon_idx + 1 to li]
                val = val.replace ('\r', '')

                vli = 0
                while val[vli] == ' '
                    vli = vli + 1
                
                val = val[vli to len (val)]

                req_dict[key] = val

        m = path
        req_dict["body"] = body

        if protocol == 'GET'
            if not path in self.r_get
                m = none
        else if protocol == 'POST'
            if not path in self.r_post
                m = none
        else
            m = none


        if m != none
            write (protocol, path)
            r = self.gen_response (m, req_dict, protocol)
            s.send (cs, r)
        else
            write (protocol, path, "(Not Found)")
        
        s.shutdown (cs, shut_codes['SHUT_WR'])
        s.close (cs)
    
    fun abort (self, cs)
        s.shutdown (cs, 1)
        s.close (cs)
    
    fun serve (self)
        sock = s.socket ()
        s.bind (sock, self.host, self.port)
        s.listen (sock, 5000)

        while 1
            try
                cs = s.accept (sock, self.host, self.port)
                th = thread (self.process, [cs])

                th.run ()
            catch E
                write ('error:', E)