import '_Native_Socket' as s
import 'thread' as thread

codes = {
    '200': 'OK',
    '201': 'Created',
    '204': 'No Content',
    '301': 'Moved Permanently',
    '302': 'Found',
    '400': 'Bad Request',
    '401': 'Unauthorized',
    '403': 'Forbidden',
    '404': 'Not Found',
    '500': 'Internal Server Error',
    '502': 'Bad Gateway',
    '503': 'Service Unavailable'
}

shut_codes = {
    'SHUT_RD': 0,
    'SHUT_WR': 1,
    'SHUT_RDWR': 2
}

class Server
    port = 0
    host = ''
    r_get = {}
    r_post = {}

    fun _init (self, host, port)
        self.port = port
        self.host = host
    
    fun add_get (self, route, callback)
        self.r_get[route] = callback
    
    fun add_post (self, route, callback)
        self.r_post[route] = callback
    
    fun gen_response (self, route)
        a = self.r_get[route] ({})

        r = "HTTP/1.1 " + a['status'].to_string () + ' ' + codes[a['status'].to_string ()] + '\r\n'
        for j in a
            if not j in ['status', 'body']
                r = r + j + ': ' + a[j] + '\r\n'
        
        if 'body' in a
            r = r + 'Content-Length: ' + len (a['body']).to_string () + '\r\n'
            r = r + '\r\n' + a['body']

        return r
    
    fun process (self, cs)
        req = s.read (cs)
        protocol = req[0 to req.find (' ')]
        path = req[len (protocol) + 1 to req[len (protocol) + 1 to len (req)].find (' ') + len (protocol) + 1]
        
        m = path

        if protocol == 'GET'
            if not path in self.r_get
                m = none

        write ("Got route:", path, "Protocol:", protocol)
        if m
            s.send (cs, self.gen_response (m))
            s.shutdown (cs, shut_codes['SHUT_WR'])
            s.close (cs)
        else
            write ('path not found (path:', path + ')')
    
    fun serve (self)
        sock = s.socket ()
        s.bind (sock, self.host, self.port)
        s.listen (sock, 10)

        while 1
            try
                cs = s.accept (sock, self.host, self.port)
                th = thread (self.process, [self, cs])

                th.run ()
            catch E
                write ('error:', E)