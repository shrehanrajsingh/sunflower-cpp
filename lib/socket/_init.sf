import '_Native_Socket' as s
import 'thread' as thread

codes = {
    '200': 'OK',
    '201': 'Created',
    '204': 'No Content',
    '301': 'Moved Permanently',
    '302': 'Found',
    '400': 'Bad Request',
    '401': 'Unauthorized',
    '403': 'Forbidden',
    '404': 'Not Found',
    '500': 'Internal Server Error',
    '502': 'Bad Gateway',
    '503': 'Service Unavailable'
}

shut_codes = {
    'SHUT_RD': 0,
    'SHUT_WR': 1,
    'SHUT_RDWR': 2
}

class Server
    port = 0
    host = ''
    r_get = {}
    r_post = {}

    fun _init (self, host, port)
        self.port = port
        self.host = host
    
    fun add_get (self, route, callback)
        self.r_get[route] = callback
    
    fun add_post (self, route, callback)
        self.r_post[route] = callback
    
    fun gen_response (self, route)
        a = self.r_get[route] ()
        p = a['status']
        as_str = p.to_string ()

        if not as_str in codes
            return ''

        r = "HTTP/1.1 " + as_str + ' ' + codes[as_str] + '\r\n'
        for j in a
            if not j in ['status', 'body']
                r = r + j + ': ' + a[j] + '\r\n'
        
        if 'body' in a
            r = r + 'Content-Length: ' + len (a['body']).to_string () + '\r\n'
            r = r + '\r\n' + a['body']

        return r
    
    fun process (self, cs)
        req = s.read (cs)
        protocol = req[0 to req.find (' ')]

        lreq = len (req)
        lp1 = len (protocol) + 1
        rf = req[lp1 to lreq].find (' ')
        rf = rf + lp1
        path = req[lp1 to rf]
        
        m = path

        if protocol == 'GET'
            if not path in self.r_get
                m = none
        else
            m = none


        write ("Got route:", path, "Protocol:", protocol, "m:", m)
        if m != none
            r = self.gen_response (m)
            s.send (cs, r)
        else
            write ('path not found (path:', path + ')')
        
        s.shutdown (cs, shut_codes['SHUT_WR'])
        s.close (cs)
    
    fun abort (self, cs)
        s.shutdown (cs, 1)
        s.close (cs)
    
    fun serve (self)
        sock = s.socket ()
        s.bind (sock, self.host, self.port)
        s.listen (sock, 5000)

        while 1
            try
                cs = s.accept (sock, self.host, self.port)
                th = thread (self.process, [cs])

                th.run ()
            catch E
                write ('error:', E)